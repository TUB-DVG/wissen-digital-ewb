# Aufbau der Produktions-Multicontainer-Architektur
Aufbau und Kommunikationswege der Multi-Container-Produktionsumgebung sind in Abb. 1 dargestellt. Es werden die an der Kommunikation mit einem Webbrowser teilnehmenden Container als Rechtecke, und eventuelle Datenflüsse als  Pfeile modelliert.
![](images/dockerComposeDeploymentStructure.png)
Der Webbrowser stellt Anfragen an den Server. Auf dem Server lauscht der "proxy"-Container über den Port "PORT_TO_OUTSIDE" auf http-Anfragen. Dabei handelt es sich bei "PORT_TO_OUTSIDE" um eine shell-Umgebungsvariable, welche beim Starten des docker-compose Projekts über die versteckte-Textdatei ".env" in die Shell geladen wird, in welche das docker-compose Projekt gestartet hat. Auf dem Server sollte "PORT_TO_OUTSIDE" mit dem Wert 80 belegt werden, damit der "proxy"-Container auf dem Port 80 auf http-Anfragen lauscht. Ankommende Anfragen werden in den "proxy"-Container übergeben, und kommen dort auf dem Port an, welcher in der Variable "NGINX_LISTEN_PORT" hinterlegt ist.
Im "proxy"-Container läuft die Anwendung nginx (gesprochen Engine X). Sie wurde während des Startvorgangs des Containers über den Befehl "nginx -g daemon off;" gestartet. Dieser Befehl startet das nginx-Programm im Container im Vordergrund. Dies entspricht der Docker-Policy, dass in einem Container immer nur ein Programm laufen sollte und hat bespielsweise den Vorteil, dass Log-Nachrichten immer an den docker-daemon weitergeleitet werden, und über den "docker log"-Befehl angezeigt werden können.
Der "proxy"-Container nimmt die Funktion eines "reverse proxy" ein (Siehe auch: https://en.wikipedia.org/wiki/Proxy_server). Er fungiert als Vermittlungseinheit und leitet die Anfrage entsprechend ihres Inhalts weiter. Enthält die Anfrage-URL einen Pfad nach "static/", greift nginx auf die jeweilige statische Datei zu, und liefert sie an den Webbrowser aus. Jede andere angefragte URL führt auf eine Weiterleitung in den "webcentral"-Container, welcher die Django-App "webcentral_app" enthält.
![Bild der nginx Konfigurationsdatei](images/nginxConfigFile.png "nginx Konfigurationsdatei")
In der nginx-Konfigurationsdatei wird eine verschachtelte Struktur erstellt. Die oberste Struktur ist die "server"-Struktur. In Zeile 2 wird der Schlüssel "listen" hinzugefügt, welcher den Port spezifiziert, auf dem nginx Anfragen entgegennimmt. Hier wird die Variable "NGINX_LISTEN_PORT" zugewiesen. Es ist hier zu beachten, dass hier nicht "PORT_TO_OUTSIDE" eingetragen werden sollte: Die Anfrage, welche über "PORT_TO_OUTSIDE" an den "proxy"-Container übergeben wurde, wird innerhalb des Containers mithilfe des Container-Port-Mappings an den Container internen Port "NGINX_LISTEN_PORT" weitergeleitet und "NGINX_LISTEN_PORT" und "PORT_TO_OUTSIDE" könnten sich unterscheiden.
In Zeile 4 und 8 werden "location"-Strukturen hinzugefügt. Die "location"-Struktur in Zeile 4 führt eine Ersetzung im angforderten Pfad vor, wenn im Pfad "/static" vorkommt. Dieser Teilpfad wird dann durch "/vol/static" ersetzt. Auf diese Weise werden statische Inhalte aus dem Docker Volume "static-data", welches in den proxy-Container über den Pfad "/vol/static" eingebunden wird, ausgeliefert. Das Kommando, welches das "static-data" Volume in den "proxy"-Container einbindet, befindet sich in der "docker-compose.prod.yml" Datei in Zeile 44.
![Bild der docker-compose-production yml-Datei](images/dockerComposeProdYmlFile.png "docker-compose.prod.yml Datei")
Die zweite "location"-Struktur in der nginx-Konfigurationsdatei (Abb. 1) wird immer dann benutzt, wenn die erste "location"-Regel nicht greift, wenn also kein "/static" in der Request-URL vorkommt. Diese Weiterleitung wird als uwsgi-Weiterleitung definiert. Der in nginx ankommende HTTP-Request wird in das uwsgi-Protokoll umgeschrieben, und an den Host, welcher über ${APP_HOST}:${UWSGI_LISTEN_PORT} definiert wird, weitergeleitet. Dabei enthält die Variable APP_HOST den Namen des Contianers, in der die webcentral Applikation liegt (Abb. 1, Zeile 9). In Zeile 10 wird dann die uwsgi_params Datei eingebunden, welche für nginx das Mapping zwischen HTTP- und uwsgi-Protokoll beschreibt. In Zeile 11 wird die maximale Größe des Request-Bodies auf 10 Megabyte begrenzt.
Um auf die statischen Daten im "static-data" Volume zugreifen zu können, müssen die statischen Daten beim Bau der Multi-Container-Produktiv-Umgebung in das "static-data" Volume kopiert werden. Dies geschieht, indem in der "settings.py" der ordner für statische Daten auf "/vol/webcentral" gelegt wird (Zeile 140 in settings.py). Durch das Ausführen von `manage.py collectstatic --noinput` in "docker-compose.prod.yml" in Zeile 21 werden die statischen Daten im Django-Projekt zusammengetragen und im "static-data" Volume aktualisiert. Weiterhin wird die Datenbank migriert und ein django-admin erstellt, falls dieser noch nicht in der Datenbank vorhanden ist. Der Parameter --noinput führt dazu, dass Username, Passwort und Email aus den Umgebungsvariablen gesetzt werden, welche im ".env" gestfelegt wurden.

Im "webcentral"-Container nimmt der uwsgi-Applikationsserver Anfragen von nginx entgegen und leitet sie an die "wsgi.py" weiter, welche sich in "webcentral_app/" befindet. Dabei lauscht uwsgi über den Port, welcher in "UWSGI_LISTEN_PORT" festgelegt wird. Die Django-App verarbeitet dann die über uwsgi erhaltene Anfrage und erstellt eine Response, welche zurück an uwsgi, und von dort an nginx weitergeleitet wird. Zum Erstellen der Response hat die Django-App die Möglichkeit an die postgres-Datenbank Anfragen zu stellen oder auf das "static-data"-Volume zuzugreifen, welches über den Pfad "/vol/webcentral" in den webcentral-Container eingebunden wurde.
Damit die postgres-Anwednung im "database"-Container nutzbar ist, müssen in der settings.py Name, Benutzername, Passwort und Hostname der Datenbank hinterlegt werden. Diese wurden als Umgebungsvariablen beim Starten des "webcentral"-Containers in den Container geladen.
Weiterhin wurde ein Mechanismus eingebaut, um die in der "settings.py" gesetzten Einstellungen zu überschreiben. Dies ist möglich, indem eine Datei "local_settings.py" im selben Ordner abgelegt wird, in dem auch die "settings.py" liegt. Weiterhin muss in der .env-Datei "USE_DOT_ENV" auf 0 gesetzt werden oder die web-App ohne Docker-Umgebung direkt über "python manage.py runserver" gestartet werden.

Der Build-Prozess des webcentral-Containers ist in zwei Phasen (im Folgenden Stages) eingeteilt. Dies ermöglicht es verschiedene Umgebungen zu erstellen. So ist es möglich eine "development"-Umgebung (kurz dev) und eine "Produktions"-Umgebung (kurz prod) zu erstellen. Dabei bauen beide Umgebungen auf demselben Base-Build auf. Dieser Base-Build der Multi-Container-App wird in "docker-compose.yml" beschrieben. Hier werden die beiden Container "database" und "webcentral" definiert. Im Kontext von docker-compose werden die Docker-Container auch "services" genannt. Der "database"-Container verwendet das Image-postres, welches von docker-hub geladen wird. Da kein Docker-Tag angegeben wurde, wird hier immer das Image mit dem Tag "latest" geladen. Die ".env"-Datei wird bei der Container-Definition ebenfalls angegeben. Mithilfe der hier hinterlegten Umgebungsvariablen "POSTGRES_USER", "POSTGRES_PASSWORD", "POSTGRES_DATABASE" wird auf die Datenbank zugegriffen, welche im Volume "pgdata" hinterlegt ist und im Container in "/var/lib/postgresql/data" eingebunden wird. Falls die Datenbank an diesem Ort nicht existiert, wird sie erstellt.
Mithilfe des "healthcheck"-Kommandos kann sichergestellt werden, dass die Datenbank noch reibungslos funktioniert, und bei Fehlern entsprechend reagiert werden. Momentan ist aber noch keine Reaktion auf Fehler implementiert. Es wäre aber zum Beispiel möglich, den "webcentral"-Container erst zu starten, wenn der "database"-Container das Signal "service_healthy" sendet. Auf diese Weise könnte sichergesetllt werden, dass der webcentral-Container erst dann startet, wenn die Datenbank vollständig hochgefahren ist (Eventuell relevant bei großen Datenbanken?).
Im Build-Prozess des "webcentral"-Containers im Base-Build wird ein "webcentral"-Image aus dem Dockerfile erstellt, welches sich im Wurzel-Ordner des "webcentral"-Git-Repositories befindet. Für das Base-Image wird nur der Teil des Dockerfiles verwendet, welcher als "base" markiert ist. Beim Build-Prozes des "base"-Images wird als Grundlage das "python3.10" Image verwendet, in welchem dann die python-Packages installiert werden, welche in der "requirements.txt" aufgeführt sind.
Dieses grundlegende "docker-compose"-Projekt kann über `docker-compose docker-compose.yml up` gestartet werden. Es ist allerdings so nicht gebräuchlich, da die Django-App noch nicht mit eingebunden ist. Dies kann durch Angabe einer weiteren ".yml"-Datei geschehen, welche vorgibt, ob ein dev- oder ein prod-build erstellt wird. Durch Ausführen des Befehls `docker-compose -f docker-compose.yml -f docker-compose.prod.yml up` wird die Produktionsumgebung der Multi-Container App erstellt. Dabei wird dem "base"-webcentral-Container eine weitere Buildstage hinzugefügt. Diese ist im Dockerfile unter dem Target-Namen "prod" sichtbar. Dort werden alle Dateien aus dem webcentral-Git-Repository in den webcentral-Container kopiert.
Für die dev-Umgebung wird der Befehl `docker-compose -f docker-compose.yml -f docker-compose.dev.yml up` ausgeführt. Hier wird, statt die Dateien aus dem webcentral-Django-Ordner zu kopieren, dieser als ordner in den "webcentral"-Container eingebunden. So können Änderungen im Quellcode direkt sichtbar gemacht werden, ohne das Docker-Compose projekt neu bauen zu müssen. Weiterhin läuft das Django-Projekt über dem Django-Development-Server.
